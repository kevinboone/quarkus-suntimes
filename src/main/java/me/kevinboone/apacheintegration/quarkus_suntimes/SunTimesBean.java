/*===========================================================================
 
  SuntimesProcessor.java

  Copyright (c)2022 Kevin Boone, GPL v3.0

===========================================================================*/

package me.kevinboone.apacheintegration.quarkus_suntimes;

import me.kevinboone.suntimes.*; 
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Date;
import java.util.List;
import java.text.SimpleDateFormat;
import java.text.ParseException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import io.quarkus.runtime.annotations.RegisterForReflection;


/** SunTimesBean contains all the application logic for this
    webservice, apart from that which is embodied in the Camel
    route. The calculate method populates an instance of
    SunTimesInfo with sunrise/set data, and returns it to the
    Camel route, where it will be formatted as JSON by Jackson. */
@RegisterForReflection
public class SunTimesBean 
  {
  static Logger logger = 
      Logger.getLogger (SunTimesBean.class.getName());

  /* We will use this DateFormat object to parse the date string supplied
     by the client. */
  static SimpleDateFormat sdf1 = 
    new SimpleDateFormat("yyyy-MM-dd");

  static TimeZone gmtTZ = TimeZone.getTimeZone ("GMT");

  /** Calculate sunrise and sunset times for the specified city on
        the specified date. */
  public SunTimesInfo calculate (String cityName, String date)
      throws SunTimesException
    {
    logger.log (Level.FINE, "city=" + cityName + ", date=" + date);

    City city = CityList.getCityByName (cityName);
    String properCityName = city.name;

    /* Rather nastily, the getTimeZone() method does not fail even
        if the timezone name is non-existant. However, we have 
        already verified that the timezone name is valid, in
        JVM terms, because it has been checked against the list in
        the City class, which is generated by Java. There's still
        the slight chance that the generation of the City class may
        have been done with a different JVM from the one running
        this application -- ideally, measures should be taken to
        prevent this.  */

    TimeZone localTZ = TimeZone.getTimeZone 
      (properCityName.replace (":", "/"));

    Calendar cal = Calendar.getInstance (gmtTZ);
    if (date == null)
      {
      logger.log (Level.FINE, "No date supplied -- using current");
      }
    else
      {
      try
        {
        /* Note that SimpleDateFormat parsing is sloppy by default. In
           a serious application, we'd probably want to check the
           client's date argument more carefully.
         
           It's also worth bearing in mind that the very nature of
           "date" here is ambiguous. The math that calculates the 
           rise/set times works on the basis of Julian dates, not
           any particular timezone. So, depending on where we are 
           with respect to the Dateline, the 24-hour period defined
           by the supplied date may not actually encompass the 
           calculated rise and set time, which could have been yesterday,
           so to speak. 

           This will only create an error of a few minutes, and only
           in regions near the Dateline. Still, a proper treatment
           of this analysis would require much more attention to 
           subtleties like this.
        */
        cal.clear();
        Date d = sdf1.parse (date);
        cal.set (Calendar.YEAR, d.getYear() + 1900);
        cal.set (Calendar.MONTH, d.getMonth());
        cal.set (Calendar.DAY_OF_MONTH, d.getDate());
        }
      catch (ParseException e)
        {
        throw new SunTimesException ("Can't parse date '" + 
          date + "': " + e.getMessage()); 
        }
      }
    
    int year = cal.get (Calendar.YEAR); 
    // Calendar's month field is zero-based, for some reason
    int month = cal.get (Calendar.MONTH) + 1; 
    int day = cal.get (Calendar.DAY_OF_MONTH); 

    logger.log (Level.FINE, "Year=" + year + ", month=" + month + 
        ", day=" + day);

    // ISO 8601 date format. Note that Jackson can, in principle, handle
    //   serialization of Java date objects automatically. The problem
    //   here is that each request on the webservice may be for a different
    //   timezone. So we can't (I think) use any kind of default
    //   deserialization. Instead, I convert the time to the required
    //   timezone and store it as a string in the model object 
    //   SunTimesInfo. I'm sure there must be a more elegant way to do
    //   this, but I can't think what it is.

    // Another complication is that any of the getSunXXX methods may
    //   throw an exception, if the result is not calculable (sunset
    //   in summer in the Arctic, for example). We must trap the 
    //   individual exceptions, because some results may, in fact,
    //   be calculable at the specific time and place. This makes the
    //   whole calculation process repetitive and ugly.

    SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX"); 
    df.setTimeZone (localTZ);

    String riseStr = null; 
    try
      {
      Time rise = Calculator.getSunriseTimeUTC_z (year, month, day, 
        city.longt, city.lat, Calculator.ZENITH);
      riseStr = doFormat (cal, rise, df);
      logger.log (Level.FINE, "Calculated UTC sunrise: " + rise);
      logger.log (Level.FINE, "Calculated local sunrise: " + riseStr);
      } catch (SunTimesException dummy) { /* not an error */  }

    String setStr = null; 
    try
      {
      Time set = Calculator.getSunsetTimeUTC_z (year, month, day, 
        city.longt, city.lat, Calculator.ZENITH);
      setStr = doFormat (cal, set, df);
      logger.log (Level.FINE, "Calculated UTC sunset: " + set);
      logger.log (Level.FINE, "Calculated local sunset: " + setStr);
      } catch (SunTimesException dummy) { /* not an error */}


    /* Wrap up the sunrise/set times in a SunTimesInfo object, to be
       returned to the Camel route. */
    return new SunTimesInfo (properCityName, 
       "" + year + "-" + month + "-" + day, riseStr, setStr);
    }

  /** Helper method to tidy up the time formatting. */
  String doFormat (Calendar cal, Time time, SimpleDateFormat df)
    {
    cal.set (Calendar.HOUR, time.getHour());
    cal.set (Calendar.MINUTE, time.getMinute());
    cal.set (Calendar.AM_PM, Calendar.AM); 
    cal.set (Calendar.SECOND, 0);
    return df.format (cal.getTime());
    }

  /** Get a list of cities. This method is just a call on the
      CityList class, which generated the list at start-up. 
      Returning the list thus creates no run-time overhead although,
      of course, serializing the massive list as JSON creates a lot
      of work for Jackson. */ 
  public List<City> list()
    {
    return CityList.getListAsList();
    }
  }


